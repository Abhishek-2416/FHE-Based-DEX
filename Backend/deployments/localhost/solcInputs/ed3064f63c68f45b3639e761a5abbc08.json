{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/Test/AMM.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IAMM.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\n\ncontract CPAMM {\n    IERC20 public  token0;\n    IERC20 public  token1;\n\n    address public immutable factory;\n\n    uint public reserve0; // internal balanceof token0\n    uint public reserve1; // internal balanceof token1 \n\n    uint public totalSupply;  // to see the total supply of shares \n    mapping(address => uint) public balanceOf;  // to map the shares of a specific address\n\n    constructor(){\n        factory = msg.sender;\n    }\n\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'FORBIDDEN'); // sufficient check\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to,uint _amount) private { // to mint the shares \n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from,uint _amount) private { // to burn the shares \n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint _reserve0, uint _reserve1) private { // to update the reserves\n        reserve0 = reserve1;\n        reserve1 = _reserve1;\n    }\n\n    function swap(address _tokenIn, uint _amountIn) external returns(uint _amountOut){\n        // Pull in tokenIn\n        // calculate tokenOut, iuncluding fees, 0.3% fee\n        // transfer tokenOut to msg.sender\n        // update the reserves\n        require(_tokenIn == address(token0) || _tokenIn == address(token1),\"Invalid input token\");\n        require(_amountIn > 0, \"Input amount too low\");\n\n        bool istoken0 = _tokenIn == address(token0);\n\n        (IERC20 _tokenIn, IERC20 _tokenOut, uint _reserveIn, uint _reserveOut) = istoken0 \n        ? (token0,token1,reserve0,reserve1) : (token1, token0,reserve1,reserve0); \n\n        // transferring tokens in \n        _tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n        \n        // calculating the amount of token to be given out (including fee)\n        // y*dx / (x + dx) = dy \n        uint _amountOutWithFee = (_amountIn * 997)/1000;\n        _amountOut = (_reserveOut * _amountIn)/(_reserveIn + _amountIn);\n\n        \n        // transferring token out \n        _tokenOut.transfer(msg.sender,_amountOut);\n        \n        // updating the reserve \n        _update(token0.balanceOf(address(this)),token1.balanceOf(address(this)));\n\n    }\n\n    // when someone add liquidity , shares mint\n    function addLiquidity(uint _amount0, uint _amount1) external returns(uint shares){ \n        // pull in token 1 and token 2 \n        // mint the shares \n        // update the reserves \n        \n        // pull in tokens \n        token0.transferFrom(msg.sender,address(this),_amount0);\n        token1.transferFrom(msg.sender,address(this),_amount1);\n\n        // dy/dx = y/x the ratio of tokens coming in == ration of the reserves of the tokens\n        if (reserve0 >0 || reserve1 > 0) {\n            require(reserve0 * _amount1 == reserve1 * _amount0, \"dy/dx != y/x\");\n        }\n\n        // mint Shares \n        // f(x,y) = value of liquidity = sqrt(x*y)\n        // shares (s) = (dx/x)T = (dy/y)T\n        if (totalSupply == 0) {\n            shares = _sqrt(_amount0 * _amount1);\n        }\n        else {\n            shares  = _min((_amount0 * totalSupply)/reserve0, (_amount1 * totalSupply)/reserve1);\n        }\n\n        require(shares > 0, \"error shares < 0\");\n        // mint the shares\n        _mint(msg.sender,shares); \n\n        // update the reserves\n        _update(token0.balanceOf(address(this)),token1.balanceOf(address(this)));\n    }\n    \n    // when someone removes liquidity , shares burn and collect the fees\n    function removerLiquidity(uint _shares) external returns(uint amount0,uint amount1){ \n        // first calculate amount0 and amount1 to withdraw \n        // dx = s / T * x\n        // dy = s / T * y\n        uint bal0 = token0.balanceOf(address(this));\n        uint bal1 = token1.balanceOf(address(this));\n\n        amount0 = (_shares * bal0) / totalSupply;\n        amount1 = (_shares * bal1) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"amount0 or amount1 is < 0\");\n\n        // burn the shares \n        _burn(msg.sender, _shares);\n\n        // update the reserves \n        _update(bal0 - amount0, bal1 - amount1);\n\n        // transfer the tokens to msg.sender \n        token0.transfer(msg.sender, amount0);\n        token1.transfer(msg.sender, amount1);\n\n\n    }\n\n    // to get the liquidity\n    function _sqrt(uint y) private pure returns(uint z) {  \n        if (y > 3) {\n            z = y;\n            uint x = y/2 + 1;\n            while(x < z){\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        }\n        else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // to get the minimum of 2 numbers\n    function _min(uint x, uint y) private pure returns(uint) { \n        return (x <= y) ? x : y;\n    }\n\n}"
    },
    "contracts/Test/Factory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nimport {CPAMM} from \"./AMM.sol\";\n\ncontract Factory {\n\n    mapping(address => mapping(address => address)) public getPair;\n\n    address[] public allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(CPAMM).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        CPAMM(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n}"
    },
    "contracts/Test/interfaces/IAMM.sol": {
      "content": "// SPDX-License-Identifier : MIT\npragma solidity 0.8.19;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}