{
  "address": "0x610178dA211FEF7D417bC0e6FeD39F05609AD788",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "publicKey",
          "type": "bytes32"
        }
      ],
      "name": "balanceOfEncrypted",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "subtractedValue",
          "type": "uint256"
        }
      ],
      "name": "decreaseAllowance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "addedValue",
          "type": "uint256"
        }
      ],
      "name": "increaseAllowance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "encryptedAmount",
          "type": "bytes"
        }
      ],
      "name": "transferEncrypted",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "amount",
          "type": "uint32"
        }
      ],
      "name": "unwrap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "amount",
          "type": "uint32"
        }
      ],
      "name": "wrap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x72f93862560effe88d6ed2ff1361896041661589df854fb67c03ad4402779901",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x610178dA211FEF7D417bC0e6FeD39F05609AD788",
    "transactionIndex": 0,
    "gasUsed": "2412540",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000020000000000000000020000000000000100000800000000000000000040000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000200000000000000000000000002000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4ca7971eaa75160eb2d20d71e53f8bc9412bf1d11ccfc2c70eaafb8cd1106e7f",
    "transactionHash": "0x72f93862560effe88d6ed2ff1361896041661589df854fb67c03ad4402779901",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 11,
        "transactionHash": "0x72f93862560effe88d6ed2ff1361896041661589df854fb67c03ad4402779901",
        "address": "0x610178dA211FEF7D417bC0e6FeD39F05609AD788",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000f4240",
        "logIndex": 0,
        "blockHash": "0x4ca7971eaa75160eb2d20d71e53f8bc9412bf1d11ccfc2c70eaafb8cd1106e7f"
      }
    ],
    "blockNumber": 11,
    "cumulativeGasUsed": "2412540",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "84274cabe1a19b3b2a9f8ee1c00ab900",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"}],\"name\":\"balanceOfEncrypted\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encryptedAmount\",\"type\":\"bytes\"}],\"name\":\"transferEncrypted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"unwrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"See {IERC20-allowance}.\"},\"approve(address,uint256)\":{\"details\":\"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address.\"},\"balanceOf(address)\":{\"details\":\"See {IERC20-balanceOf}.\"},\"decimals()\":{\"details\":\"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.\"},\"decreaseAllowance(address,uint256)\":{\"details\":\"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.\"},\"increaseAllowance(address,uint256)\":{\"details\":\"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.\"},\"name()\":{\"details\":\"Returns the name of the token.\"},\"symbol()\":{\"details\":\"Returns the symbol of the token, usually a shorter version of the name.\"},\"totalSupply()\":{\"details\":\"See {IERC20-totalSupply}.\"},\"transfer(address,uint256)\":{\"details\":\"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/NormalETHERC20.sol\":\"NormalETHERC20\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa56ca923f70c1748830700250b19c61b70db9a683516dc5e216694a50445d99c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xa92e4fa126feb6907daa0513ddd816b2eb91f30a808de54f63c17d0e162c3439\",\"license\":\"MIT\"},\"contracts/NormalETHERC20.sol\":{\"content\":\"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\n\\ncontract NormalETHERC20 is ERC20 {\\n\\n    address immutable i_owner;\\n    mapping(address => euint32) private _encBalances;\\n\\n    constructor() ERC20(\\\"ETHERC20\\\",\\\"ETH\\\") {\\n        i_owner = msg.sender;\\n        mint(msg.sender, 1000000);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 3;\\n    }\\n\\n    function mint(address to, uint256 amount) public {\\n        if (msg.sender != i_owner) {\\n            revert ();\\n        }\\n        _mint(to, amount);\\n    }\\n\\n    function wrap(uint32 amount) public {\\n        require(balanceOf(msg.sender) >= amount, \\\"must have enough tokens to wrap\\\");\\n        _burn(msg.sender, amount);\\n        _encBalances[msg.sender] = TFHE.add(_encBalances[msg.sender], TFHE.asEuint32(amount));\\n    }\\n\\n    function unwrap(uint32 amount) public {\\n        TFHE.optReq(TFHE.gt(_encBalances[msg.sender], amount));\\n\\n        _encBalances[msg.sender] = TFHE.sub(_encBalances[msg.sender], TFHE.asEuint32(amount));\\n\\n        _mint(msg.sender, amount);\\n    }\\n\\n    function transferEncrypted(address to, bytes calldata encryptedAmount) public {\\n        _transferEncrypted(to, TFHE.asEuint32(encryptedAmount));\\n    }\\n\\n    // Transfers an amount from the message sender address to the `to` address.\\n    function _transferEncrypted(address to, euint32 amount) internal {\\n        _transferImpl(msg.sender, to, amount);\\n    }\\n\\n    // Transfers an encrypted amount.\\n    function _transferImpl(address from, address to, euint32 amount) internal {\\n        // Make sure the sender has enough tokens.\\n        TFHE.optReq(TFHE.le(amount, _encBalances[from]));\\n\\n        // Add to the balance of `to` and subract from the balance of `from`.\\n        _encBalances[to] = TFHE.add(_encBalances[to], amount);\\n        _encBalances[from] = TFHE.sub(_encBalances[from], amount);\\n    }\\n\\n    function balanceOfEncrypted(bytes32 publicKey) public view returns (bytes memory) {\\n        return TFHE.reencrypt(_encBalances[msg.sender], publicKey);\\n    }\\n}\\n\",\"keccak256\":\"0x3fa6db2e5221fb66e8fbe01d98d8d2ba39680d519f4609c49f71934205a1f9ce\",\"license\":\"SEE LICENSE IN LICENSE\"},\"fhevm/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity 0.8.19;\\n\\ninterface FhevmLib {\\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\\n\\n    function fheNeg(uint256 ct) external pure returns (uint256 result);\\n\\n    function fheNot(uint256 ct) external pure returns (uint256 result);\\n\\n    function optimisticRequire(uint256 ct) external view;\\n\\n    function reencrypt(uint256 ct, uint256 publicKey) external view returns (bytes memory);\\n\\n    function fhePubKey(bytes1 fromLib) external view returns (bytes memory result);\\n\\n    function verifyCiphertext(bytes memory input) external pure returns (uint256 result);\\n\\n    function cast(uint256 ct, bytes1 toType) external pure returns (uint256 result);\\n\\n    function trivialEncrypt(uint256 ct, bytes1 toType) external pure returns (uint256 result);\\n\\n    function decrypt(uint256 ct) external view returns (uint256 result);\\n\\n    function fheRand(bytes1 inp) external view returns (uint256 result);\\n}\\n\\naddress constant EXT_TFHE_LIBRARY = address(93);\\n\\nlibrary Impl {\\n    // 32 bytes for the 'byte' type header + 48 bytes for the NaCl anonymous\\n    // box overhead + 4 bytes for the plaintext value.\\n    uint256 constant reencryptedSize = 32 + 48 + 4;\\n\\n    // 32 bytes for the 'byte' header + 16553 bytes of key data.\\n    uint256 constant fhePubKeySize = 32 + 16553;\\n\\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\\n        bytes1 scalarByte = 0x00;\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\\n        bytes1 scalarByte = 0x00;\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\\n        bytes1 scalarByte = 0x00;\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(uint256 ct) internal pure returns (uint256 result) {\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNeg(ct);\\n    }\\n\\n    function not(uint256 ct) internal pure returns (uint256 result) {\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNot(ct);\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n    function cmux(uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\\n        // result = (ifTrue - ifFalse) * control + ifFalse\\n        uint256 subOutput = FhevmLib(address(EXT_TFHE_LIBRARY)).fheSub(ifTrue, ifFalse, bytes1(0x00));\\n        uint256 mulOutput = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMul(control, subOutput, bytes1(0x00));\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheAdd(mulOutput, ifFalse, bytes1(0x00));\\n    }\\n\\n    function optReq(uint256 ciphertext) internal view {\\n        FhevmLib(address(EXT_TFHE_LIBRARY)).optimisticRequire(ciphertext);\\n    }\\n\\n    function reencrypt(uint256 ciphertext, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\\n        return FhevmLib(address(EXT_TFHE_LIBRARY)).reencrypt(ciphertext, uint256(publicKey));\\n    }\\n\\n    function fhePubKey() internal view returns (bytes memory key) {\\n        // Set a byte value of 1 to signal the call comes from the library.\\n        key = FhevmLib(address(EXT_TFHE_LIBRARY)).fhePubKey(bytes1(0x01));\\n    }\\n\\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\\n        bytes memory input = bytes.concat(_ciphertextBytes, bytes1(_toType));\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).verifyCiphertext(input);\\n    }\\n\\n    function cast(uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).cast(ciphertext, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function decrypt(uint256 ciphertext) internal view returns (uint256 result) {\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).decrypt(ciphertext);\\n    }\\n\\n    function rand(uint8 randType) internal view returns (uint256 result) {\\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheRand(bytes1(randType));\\n    }\\n}\\n\",\"keccak256\":\"0xde2e1a5a94d7b427f8a99b9eb321221c2e7f9856c3520deaa52caab80bd30ccb\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/TFHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity 0.8.19;\\n\\ntype ebool is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\n\\nlibrary Common {\\n    // Values used to communicate types to the runtime.\\n    uint8 internal constant ebool_t = 0;\\n    uint8 internal constant euint8_t = 0;\\n    uint8 internal constant euint16_t = 1;\\n    uint8 internal constant euint32_t = 2;\\n}\\n\\nimport \\\"./Impl.sol\\\";\\n\\nlibrary TFHE {\\n    euint8 constant NIL8 = euint8.wrap(0);\\n    euint16 constant NIL16 = euint16.wrap(0);\\n    euint32 constant NIL32 = euint32.wrap(0);\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint8 b) internal pure returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(uint8 a, euint8 b) internal pure returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(uint8 a, euint8 b) internal pure returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, uint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, uint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, uint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, uint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, uint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, uint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, uint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint8 b) internal pure returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint8 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint16 a, euint16 b) internal pure returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(uint16 a, euint16 b) internal pure returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(uint16 a, euint16 b) internal pure returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, uint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, uint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, uint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, uint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, uint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, uint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint16 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, uint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint16 a, euint16 b) internal pure returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint8 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint8 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint16 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint16 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint32 a, euint32 b) internal pure returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(uint32 a, euint32 b) internal pure returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(uint32 a, euint32 b) internal pure returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, uint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, uint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, uint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, uint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, uint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, uint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint32 a, euint32 b) internal pure returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, uint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint32 a, euint32 b) internal pure returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function cmux(ebool control, euint8 a, euint8 b) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cmux(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'a'.\\n    // If 'control's value is 'false', the result has the same value as 'b'.\\n    function cmux(ebool control, euint16 a, euint16 b) internal pure returns (euint16) {\\n        euint16 ctrl = asEuint16(asEuint8(control));\\n        return euint16.wrap(Impl.cmux(euint16.unwrap(ctrl), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'a'.\\n    // If 'control's value is 'false', the result has the same value as 'b'.\\n    function cmux(ebool control, euint32 a, euint32 b) internal pure returns (euint32) {\\n        euint32 ctrl = asEuint32(asEuint8(control));\\n        return euint32.wrap(Impl.cmux(euint32.unwrap(ctrl), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint8.\\n    function asEuint8(euint16 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint8.\\n    function asEuint8(euint32 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to ebool.\\n    function asEbool(euint8 value) internal pure returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Convert a serialized 'ciphertext' to an encrypted boolean.\\n    function asEbool(bytes memory ciphertext) internal pure returns (ebool) {\\n        return asEbool(asEuint8(ciphertext));\\n    }\\n\\n    // Convert a plaintext boolean to an encrypted boolean.\\n    function asEbool(bool value) internal pure returns (ebool) {\\n        if (value) {\\n            return asEbool(asEuint8(1));\\n        } else {\\n            return asEbool(asEuint8(0));\\n        }\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint16.\\n    function asEuint16(euint8 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint16.\\n    function asEuint16(euint32 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to ebool.\\n    function asEbool(euint16 value) internal pure returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint32.\\n    function asEuint32(euint8 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint32.\\n    function asEuint32(euint16 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to ebool.\\n    function asEbool(euint32 value) internal pure returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    function neg(euint8 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    function not(euint8 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    function neg(euint16 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    function not(euint16 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    function neg(euint32 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    function not(euint32 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    // Convert a serialized 'ciphertext' to an encrypted euint8 integer.\\n    function asEuint8(bytes memory ciphertext) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.verify(ciphertext, Common.euint8_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint8 integer.\\n    function asEuint8(uint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // Return a serialized euint8 ciphertext.\\n    function reencrypt(euint8 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\\n        return Impl.reencrypt(euint8.unwrap(value), publicKey);\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\\n    // Return a serialized euint8 ciphertext.\\n    function reencrypt(\\n        euint8 value,\\n        bytes32 publicKey,\\n        uint8 defaultValue\\n    ) internal view returns (bytes memory reencrypted) {\\n        if (euint8.unwrap(value) != 0) {\\n            return Impl.reencrypt(euint8.unwrap(value), publicKey);\\n        } else {\\n            return Impl.reencrypt(euint8.unwrap(asEuint8(defaultValue)), publicKey);\\n        }\\n    }\\n\\n    // Decrypts the encrypted 'value'.\\n    function decrypt(euint8 value) internal view returns (uint8) {\\n        return uint8(Impl.decrypt(euint8.unwrap(value)));\\n    }\\n\\n    // Convert a serialized 'ciphertext' to an encrypted euint16 integer.\\n    function asEuint16(bytes memory ciphertext) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.verify(ciphertext, Common.euint16_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint16 integer.\\n    function asEuint16(uint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // Return a serialized euint16 ciphertext.\\n    function reencrypt(euint16 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\\n        return Impl.reencrypt(euint16.unwrap(value), publicKey);\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\\n    // Return a serialized euint16 ciphertext.\\n    function reencrypt(\\n        euint16 value,\\n        bytes32 publicKey,\\n        uint16 defaultValue\\n    ) internal view returns (bytes memory reencrypted) {\\n        if (euint16.unwrap(value) != 0) {\\n            return Impl.reencrypt(euint16.unwrap(value), publicKey);\\n        } else {\\n            return Impl.reencrypt(euint16.unwrap(asEuint16(defaultValue)), publicKey);\\n        }\\n    }\\n\\n    // Decrypts the encrypted 'value'.\\n    function decrypt(euint16 value) internal view returns (uint16) {\\n        return uint16(Impl.decrypt(euint16.unwrap(value)));\\n    }\\n\\n    // Convert a serialized 'ciphertext' to an encrypted euint32 integer.\\n    function asEuint32(bytes memory ciphertext) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.verify(ciphertext, Common.euint32_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint32 integer.\\n    function asEuint32(uint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // Return a serialized euint32 ciphertext.\\n    function reencrypt(euint32 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\\n        return Impl.reencrypt(euint32.unwrap(value), publicKey);\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\\n    // Return a serialized euint32 ciphertext.\\n    function reencrypt(\\n        euint32 value,\\n        bytes32 publicKey,\\n        uint32 defaultValue\\n    ) internal view returns (bytes memory reencrypted) {\\n        if (euint32.unwrap(value) != 0) {\\n            return Impl.reencrypt(euint32.unwrap(value), publicKey);\\n        } else {\\n            return Impl.reencrypt(euint32.unwrap(asEuint32(defaultValue)), publicKey);\\n        }\\n    }\\n\\n    // Decrypts the encrypted 'value'.\\n    function decrypt(euint32 value) internal view returns (uint32) {\\n        return uint32(Impl.decrypt(euint32.unwrap(value)));\\n    }\\n\\n    // Optimistically require that 'b' is true.\\n    //\\n    // This function does not evaluate 'b' at the time of the call.\\n    // Instead, it accumulates all optimistic requires and evaluates a single combined\\n    // require at the end of the transaction. A side effect of this mechanism\\n    // is that a method call with a failed optimistic require will always incur the full\\n    // gas cost, as if all optimistic requires were true. Yet, the transaction will be\\n    // reverted at the end if any of the optimisic requires were false.\\n    //\\n    // Exceptions to above rule are reencryptions and decryptions via\\n    // TFHE.reencrypt() and TFHE.decrypt(), respectively. If either of them\\n    // are encountered and if optimistic requires have been used before in the\\n    // txn, the optimisic requires will be immediately evaluated. Rationale is\\n    // that we want to avoid decrypting or reencrypting a value if the txn is about\\n    // to fail and be reverted anyway at the end. Checking immediately and reverting on the spot\\n    // would avoid unnecessary decryptions.\\n    //\\n    // The benefit of optimistic requires is that they are faster than non-optimistic ones,\\n    // because there is a single call to the decryption oracle per transaction, irrespective\\n    // of how many optimistic requires were used.\\n    function optReq(ebool b) internal view {\\n        Impl.optReq(ebool.unwrap(b));\\n    }\\n\\n    // Decrypts the encrypted 'value'.\\n    function decrypt(ebool value) internal view returns (bool) {\\n        return (Impl.decrypt(ebool.unwrap(value)) != 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint8'.\\n    function asEuint8(ebool b) internal pure returns (euint8) {\\n        return euint8.wrap(ebool.unwrap(b));\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // Return a serialized euint8 value.\\n    function reencrypt(ebool value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\\n        return Impl.reencrypt(ebool.unwrap(value), publicKey);\\n    }\\n\\n    // Reencrypt the given 'value' under the given 'publicKey'.\\n    // Return a serialized euint8 value.\\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\\n    function reencrypt(\\n        ebool value,\\n        bytes32 publicKey,\\n        bool defaultValue\\n    ) internal view returns (bytes memory reencrypted) {\\n        if (ebool.unwrap(value) != 0) {\\n            return Impl.reencrypt(ebool.unwrap(value), publicKey);\\n        } else {\\n            return Impl.reencrypt(ebool.unwrap(asEbool(defaultValue)), publicKey);\\n        }\\n    }\\n\\n    // Returns the network public FHE key.\\n    function fhePubKey() internal view returns (bytes memory) {\\n        return Impl.fhePubKey();\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer.\\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\\n    function randEuint8() internal view returns (euint8) {\\n        return euint8.wrap(Impl.rand(Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer.\\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\\n    function randEuint16() internal view returns (euint16) {\\n        return euint16.wrap(Impl.rand(Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer.\\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\\n    function randEuint32() internal view returns (euint32) {\\n        return euint32.wrap(Impl.rand(Common.euint32_t));\\n    }\\n}\\n\\nusing {tfheBinaryOperatorAdd8 as +} for euint8 global;\\n\\nfunction tfheBinaryOperatorAdd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return TFHE.add(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorSub8 as -} for euint8 global;\\n\\nfunction tfheBinaryOperatorSub8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return TFHE.sub(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorMul8 as *} for euint8 global;\\n\\nfunction tfheBinaryOperatorMul8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return TFHE.mul(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorAnd8 as &} for euint8 global;\\n\\nfunction tfheBinaryOperatorAnd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return TFHE.and(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorOr8 as |} for euint8 global;\\n\\nfunction tfheBinaryOperatorOr8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return TFHE.or(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorXor8 as ^} for euint8 global;\\n\\nfunction tfheBinaryOperatorXor8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return TFHE.xor(lhs, rhs);\\n}\\n\\nusing {tfheUnaryOperatorNeg8 as -} for euint8 global;\\n\\nfunction tfheUnaryOperatorNeg8(euint8 input) pure returns (euint8) {\\n    return TFHE.neg(input);\\n}\\n\\nusing {tfheUnaryOperatorNot8 as ~} for euint8 global;\\n\\nfunction tfheUnaryOperatorNot8(euint8 input) pure returns (euint8) {\\n    return TFHE.not(input);\\n}\\n\\nusing {tfheBinaryOperatorAdd16 as +} for euint16 global;\\n\\nfunction tfheBinaryOperatorAdd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return TFHE.add(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorSub16 as -} for euint16 global;\\n\\nfunction tfheBinaryOperatorSub16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return TFHE.sub(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorMul16 as *} for euint16 global;\\n\\nfunction tfheBinaryOperatorMul16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return TFHE.mul(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorAnd16 as &} for euint16 global;\\n\\nfunction tfheBinaryOperatorAnd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return TFHE.and(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorOr16 as |} for euint16 global;\\n\\nfunction tfheBinaryOperatorOr16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return TFHE.or(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorXor16 as ^} for euint16 global;\\n\\nfunction tfheBinaryOperatorXor16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return TFHE.xor(lhs, rhs);\\n}\\n\\nusing {tfheUnaryOperatorNeg16 as -} for euint16 global;\\n\\nfunction tfheUnaryOperatorNeg16(euint16 input) pure returns (euint16) {\\n    return TFHE.neg(input);\\n}\\n\\nusing {tfheUnaryOperatorNot16 as ~} for euint16 global;\\n\\nfunction tfheUnaryOperatorNot16(euint16 input) pure returns (euint16) {\\n    return TFHE.not(input);\\n}\\n\\nusing {tfheBinaryOperatorAdd32 as +} for euint32 global;\\n\\nfunction tfheBinaryOperatorAdd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return TFHE.add(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorSub32 as -} for euint32 global;\\n\\nfunction tfheBinaryOperatorSub32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return TFHE.sub(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorMul32 as *} for euint32 global;\\n\\nfunction tfheBinaryOperatorMul32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return TFHE.mul(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorAnd32 as &} for euint32 global;\\n\\nfunction tfheBinaryOperatorAnd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return TFHE.and(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorOr32 as |} for euint32 global;\\n\\nfunction tfheBinaryOperatorOr32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return TFHE.or(lhs, rhs);\\n}\\n\\nusing {tfheBinaryOperatorXor32 as ^} for euint32 global;\\n\\nfunction tfheBinaryOperatorXor32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return TFHE.xor(lhs, rhs);\\n}\\n\\nusing {tfheUnaryOperatorNeg32 as -} for euint32 global;\\n\\nfunction tfheUnaryOperatorNeg32(euint32 input) pure returns (euint32) {\\n    return TFHE.neg(input);\\n}\\n\\nusing {tfheUnaryOperatorNot32 as ~} for euint32 global;\\n\\nfunction tfheUnaryOperatorNot32(euint32 input) pure returns (euint32) {\\n    return TFHE.not(input);\\n}\\n\",\"keccak256\":\"0x36cbc2982e1c8a1c6f0c3bc27b7c7a56233104b6be34bf9a70882d40ab6a63cf\",\"license\":\"BSD-3-Clause-Clear\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b506040518060400160405280600881526020017f45544845524332300000000000000000000000000000000000000000000000008152506040518060400160405280600381526020017f455448000000000000000000000000000000000000000000000000000000000081525081600390816200008f919062000535565b508060049081620000a1919062000535565b5050503373ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff1681525050620000ed33620f4240620000f360201b60201c565b62000737565b60805173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146200012e57600080fd5b6200014082826200014460201b60201c565b5050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603620001b6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401620001ad906200067d565b60405180910390fd5b620001ca60008383620002b160201b60201c565b8060026000828254620001de9190620006ce565b92505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516200029191906200071a565b60405180910390a3620002ad60008383620002b660201b60201c565b5050565b505050565b505050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806200033d57607f821691505b602082108103620003535762000352620002f5565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302620003bd7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826200037e565b620003c986836200037e565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b600062000416620004106200040a84620003e1565b620003eb565b620003e1565b9050919050565b6000819050919050565b6200043283620003f5565b6200044a62000441826200041d565b8484546200038b565b825550505050565b600090565b6200046162000452565b6200046e81848462000427565b505050565b5b8181101562000496576200048a60008262000457565b60018101905062000474565b5050565b601f821115620004e557620004af8162000359565b620004ba846200036e565b81016020851015620004ca578190505b620004e2620004d9856200036e565b83018262000473565b50505b505050565b600082821c905092915050565b60006200050a60001984600802620004ea565b1980831691505092915050565b6000620005258383620004f7565b9150826002028217905092915050565b6200054082620002bb565b67ffffffffffffffff8111156200055c576200055b620002c6565b5b62000568825462000324565b620005758282856200049a565b600060209050601f831160018114620005ad576000841562000598578287015190505b620005a4858262000517565b86555062000614565b601f198416620005bd8662000359565b60005b82811015620005e757848901518255600182019150602085019450602081019050620005c0565b8683101562000607578489015162000603601f891682620004f7565b8355505b6001600288020188555050505b505050505050565b600082825260208201905092915050565b7f45524332303a206d696e7420746f20746865207a65726f206164647265737300600082015250565b600062000665601f836200061c565b915062000672826200062d565b602082019050919050565b60006020820190508181036000830152620006988162000656565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000620006db82620003e1565b9150620006e883620003e1565b92508282019050808211156200070357620007026200069f565b5b92915050565b6200071481620003e1565b82525050565b600060208201905062000731600083018462000709565b92915050565b6080516128b06200075360003960006104ef01526128b06000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80636e0505e111610097578063a457c2d711610066578063a457c2d7146102c1578063a9059cbb146102f1578063bfd83c5414610321578063dd62ed3e1461033d57610100565b80636e0505e11461023b57806370a082311461025757806395d89b41146102875780639f284be7146102a557610100565b806323b872dd116100d357806323b872dd146101a1578063313ce567146101d157806339509351146101ef57806340c10f191461021f57610100565b806306fdde0314610105578063095ea7b3146101235780631744ff9c1461015357806318160ddd14610183575b600080fd5b61010d61036d565b60405161011a9190611a85565b60405180910390f35b61013d60048036038101906101389190611b4f565b6103ff565b60405161014a9190611baa565b60405180910390f35b61016d60048036038101906101689190611bfb565b610422565b60405161017a9190611c7d565b60405180910390f35b61018b610474565b6040516101989190611cae565b60405180910390f35b6101bb60048036038101906101b69190611cc9565b61047e565b6040516101c89190611baa565b60405180910390f35b6101d96104ad565b6040516101e69190611d38565b60405180910390f35b61020960048036038101906102049190611b4f565b6104b6565b6040516102169190611baa565b60405180910390f35b61023960048036038101906102349190611b4f565b6104ed565b005b61025560048036038101906102509190611d8f565b610553565b005b610271600480360381019061026c9190611dbc565b610651565b60405161027e9190611cae565b60405180910390f35b61028f610699565b60405161029c9190611a85565b60405180910390f35b6102bf60048036038101906102ba9190611d8f565b61072b565b005b6102db60048036038101906102d69190611b4f565b610829565b6040516102e89190611baa565b60405180910390f35b61030b60048036038101906103069190611b4f565b6108a0565b6040516103189190611baa565b60405180910390f35b61033b60048036038101906103369190611e4e565b6108c3565b005b61035760048036038101906103529190611eae565b61091e565b6040516103649190611cae565b60405180910390f35b60606003805461037c90611f1d565b80601f01602080910402602001604051908101604052809291908181526020018280546103a890611f1d565b80156103f55780601f106103ca576101008083540402835291602001916103f5565b820191906000526020600020905b8154815290600101906020018083116103d857829003601f168201915b5050505050905090565b60008061040a6109a5565b90506104178185856109ad565b600191505092915050565b606061046d600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483610b76565b9050919050565b6000600254905090565b6000806104896109a5565b9050610496858285610b8a565b6104a1858585610c16565b60019150509392505050565b60006003905090565b6000806104c16109a5565b90506104e28185856104d3858961091e565b6104dd9190611f7d565b6109ad565b600191505092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461054557600080fd5b61054f8282610e8c565b5050565b6105a461059f600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483610fe2565b611022565b6105fb600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546105f68363ffffffff1661102e565b611042565b600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061064e338263ffffffff16610e8c565b50565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b6060600480546106a890611f1d565b80601f01602080910402602001604051908101604052809291908181526020018280546106d490611f1d565b80156107215780601f106106f657610100808354040283529160200191610721565b820191906000526020600020905b81548152906001019060200180831161070457829003601f168201915b5050505050905090565b8063ffffffff1661073b33610651565b101561077c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161077390611ffd565b60405180910390fd5b61078c338263ffffffff1661108c565b6107e3600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546107de8363ffffffff1661102e565b611259565b600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050565b6000806108346109a5565b90506000610842828661091e565b905083811015610887576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161087e9061208f565b60405180910390fd5b61089482868684036109ad565b60019250505092915050565b6000806108ab6109a5565b90506108b8818585610c16565b600191505092915050565b6109198361091484848080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506112a3565b6112b7565b505050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b600033905090565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610a1c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a1390612121565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610a8b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a82906121b3565b60405180910390fd5b80600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92583604051610b699190611cae565b60405180910390a3505050565b6060610b8283836112c6565b905092915050565b6000610b96848461091e565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610c105781811015610c02576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bf99061221f565b60405180910390fd5b610c0f84848484036109ad565b5b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610c85576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c7c906122b1565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610cf4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ceb90612343565b60405180910390fd5b610cff838383611355565b60008060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081811015610d85576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d7c906123d5565b60405180910390fd5b8181036000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef84604051610e739190611cae565b60405180910390a3610e8684848461135a565b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610efb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ef290612441565b60405180910390fd5b610f0760008383611355565b8060026000828254610f199190611f7d565b92505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610fca9190611cae565b60405180910390a3610fde6000838361135a565b5050565b6000610fed8361135f565b610ffe57610ffb600061102e565b92505b61101a611013848463ffffffff16600161136c565b6000611412565b905092915050565b61102b8161149c565b50565b600061103b826002611509565b9050919050565b600061104d8361135f565b61105e5761105b600061102e565b92505b6110678261135f565b61107857611075600061102e565b91505b61108483836000611593565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036110fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110f2906124d3565b60405180910390fd5b61110782600083611355565b60008060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508181101561118d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161118490612565565b60405180910390fd5b8181036000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081600260008282540392505081905550600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516112409190611cae565b60405180910390a36112548360008461135a565b505050565b60006112648361135f565b61127557611272600061102e565b92505b61127e8261135f565b61128f5761128c600061102e565b91505b61129b83836000611639565b905092915050565b60006112b08260026116df565b9050919050565b6112c233838361178d565b5050565b6060605d73ffffffffffffffffffffffffffffffffffffffff1663d6ad57cd848460001c6040518363ffffffff1660e01b8152600401611307929190612585565b600060405180830381865afa158015611324573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061134d91906126cf565b905092915050565b505050565b505050565b6000808214159050919050565b600080821561138157600160f81b9050611389565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff16633e63c50a8686846040518463ffffffff1660e01b81526004016113c793929190612753565b602060405180830381865afa1580156113e4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611408919061279f565b9150509392505050565b6000605d73ffffffffffffffffffffffffffffffffffffffff16634be68d20848460f81b6040518363ffffffff1660e01b81526004016114539291906127cc565b602060405180830381865afa158015611470573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611494919061279f565b905092915050565b605d73ffffffffffffffffffffffffffffffffffffffff16634ee071a1826040518263ffffffff1660e01b81526004016114d69190611cae565b60006040518083038186803b1580156114ee57600080fd5b505afa158015611502573d6000803e3d6000fd5b5050505050565b6000605d73ffffffffffffffffffffffffffffffffffffffff1663e71746b8848460f81b6040518363ffffffff1660e01b815260040161154a9291906127cc565b602060405180830381865afa158015611567573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061158b919061279f565b905092915050565b60008082156115a857600160f81b90506115b0565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff16638c14cc218686846040518463ffffffff1660e01b81526004016115ee93929190612753565b602060405180830381865afa15801561160b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061162f919061279f565b9150509392505050565b600080821561164e57600160f81b9050611656565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff1663f953e4278686846040518463ffffffff1660e01b815260040161169493929190612753565b602060405180830381865afa1580156116b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116d5919061279f565b9150509392505050565b600080838360f81b6040516020016116f8929190612852565b6040516020818303038152906040529050605d73ffffffffffffffffffffffffffffffffffffffff16634b252ec8826040518263ffffffff1660e01b81526004016117439190611c7d565b602060405180830381865afa158015611760573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611784919061279f565b91505092915050565b6117de6117d982600560008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546118fb565b611022565b611827600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482611259565b600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506118b3600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482611042565b600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550505050565b60006119068361135f565b61191757611914600061102e565b92505b6119208261135f565b6119315761192e600061102e565b91505b6119476119408484600061194f565b6000611412565b905092915050565b600080821561196457600160f81b905061196c565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff1663694daf728686846040518463ffffffff1660e01b81526004016119aa93929190612753565b602060405180830381865afa1580156119c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119eb919061279f565b9150509392505050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611a2f578082015181840152602081019050611a14565b60008484015250505050565b6000601f19601f8301169050919050565b6000611a57826119f5565b611a618185611a00565b9350611a71818560208601611a11565b611a7a81611a3b565b840191505092915050565b60006020820190508181036000830152611a9f8184611a4c565b905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611ae682611abb565b9050919050565b611af681611adb565b8114611b0157600080fd5b50565b600081359050611b1381611aed565b92915050565b6000819050919050565b611b2c81611b19565b8114611b3757600080fd5b50565b600081359050611b4981611b23565b92915050565b60008060408385031215611b6657611b65611ab1565b5b6000611b7485828601611b04565b9250506020611b8585828601611b3a565b9150509250929050565b60008115159050919050565b611ba481611b8f565b82525050565b6000602082019050611bbf6000830184611b9b565b92915050565b6000819050919050565b611bd881611bc5565b8114611be357600080fd5b50565b600081359050611bf581611bcf565b92915050565b600060208284031215611c1157611c10611ab1565b5b6000611c1f84828501611be6565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000611c4f82611c28565b611c598185611c33565b9350611c69818560208601611a11565b611c7281611a3b565b840191505092915050565b60006020820190508181036000830152611c978184611c44565b905092915050565b611ca881611b19565b82525050565b6000602082019050611cc36000830184611c9f565b92915050565b600080600060608486031215611ce257611ce1611ab1565b5b6000611cf086828701611b04565b9350506020611d0186828701611b04565b9250506040611d1286828701611b3a565b9150509250925092565b600060ff82169050919050565b611d3281611d1c565b82525050565b6000602082019050611d4d6000830184611d29565b92915050565b600063ffffffff82169050919050565b611d6c81611d53565b8114611d7757600080fd5b50565b600081359050611d8981611d63565b92915050565b600060208284031215611da557611da4611ab1565b5b6000611db384828501611d7a565b91505092915050565b600060208284031215611dd257611dd1611ab1565b5b6000611de084828501611b04565b91505092915050565b600080fd5b600080fd5b600080fd5b60008083601f840112611e0e57611e0d611de9565b5b8235905067ffffffffffffffff811115611e2b57611e2a611dee565b5b602083019150836001820283011115611e4757611e46611df3565b5b9250929050565b600080600060408486031215611e6757611e66611ab1565b5b6000611e7586828701611b04565b935050602084013567ffffffffffffffff811115611e9657611e95611ab6565b5b611ea286828701611df8565b92509250509250925092565b60008060408385031215611ec557611ec4611ab1565b5b6000611ed385828601611b04565b9250506020611ee485828601611b04565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611f3557607f821691505b602082108103611f4857611f47611eee565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611f8882611b19565b9150611f9383611b19565b9250828201905080821115611fab57611faa611f4e565b5b92915050565b7f6d757374206861766520656e6f75676820746f6b656e7320746f207772617000600082015250565b6000611fe7601f83611a00565b9150611ff282611fb1565b602082019050919050565b6000602082019050818103600083015261201681611fda565b9050919050565b7f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760008201527f207a65726f000000000000000000000000000000000000000000000000000000602082015250565b6000612079602583611a00565b91506120848261201d565b604082019050919050565b600060208201905081810360008301526120a88161206c565b9050919050565b7f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460008201527f7265737300000000000000000000000000000000000000000000000000000000602082015250565b600061210b602483611a00565b9150612116826120af565b604082019050919050565b6000602082019050818103600083015261213a816120fe565b9050919050565b7f45524332303a20617070726f766520746f20746865207a65726f20616464726560008201527f7373000000000000000000000000000000000000000000000000000000000000602082015250565b600061219d602283611a00565b91506121a882612141565b604082019050919050565b600060208201905081810360008301526121cc81612190565b9050919050565b7f45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000600082015250565b6000612209601d83611a00565b9150612214826121d3565b602082019050919050565b60006020820190508181036000830152612238816121fc565b9050919050565b7f45524332303a207472616e736665722066726f6d20746865207a65726f20616460008201527f6472657373000000000000000000000000000000000000000000000000000000602082015250565b600061229b602583611a00565b91506122a68261223f565b604082019050919050565b600060208201905081810360008301526122ca8161228e565b9050919050565b7f45524332303a207472616e7366657220746f20746865207a65726f206164647260008201527f6573730000000000000000000000000000000000000000000000000000000000602082015250565b600061232d602383611a00565b9150612338826122d1565b604082019050919050565b6000602082019050818103600083015261235c81612320565b9050919050565b7f45524332303a207472616e7366657220616d6f756e742065786365656473206260008201527f616c616e63650000000000000000000000000000000000000000000000000000602082015250565b60006123bf602683611a00565b91506123ca82612363565b604082019050919050565b600060208201905081810360008301526123ee816123b2565b9050919050565b7f45524332303a206d696e7420746f20746865207a65726f206164647265737300600082015250565b600061242b601f83611a00565b9150612436826123f5565b602082019050919050565b6000602082019050818103600083015261245a8161241e565b9050919050565b7f45524332303a206275726e2066726f6d20746865207a65726f2061646472657360008201527f7300000000000000000000000000000000000000000000000000000000000000602082015250565b60006124bd602183611a00565b91506124c882612461565b604082019050919050565b600060208201905081810360008301526124ec816124b0565b9050919050565b7f45524332303a206275726e20616d6f756e7420657863656564732062616c616e60008201527f6365000000000000000000000000000000000000000000000000000000000000602082015250565b600061254f602283611a00565b915061255a826124f3565b604082019050919050565b6000602082019050818103600083015261257e81612542565b9050919050565b600060408201905061259a6000830185611c9f565b6125a76020830184611c9f565b9392505050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6125eb82611a3b565b810181811067ffffffffffffffff8211171561260a576126096125b3565b5b80604052505050565b600061261d611aa7565b905061262982826125e2565b919050565b600067ffffffffffffffff821115612649576126486125b3565b5b61265282611a3b565b9050602081019050919050565b600061267261266d8461262e565b612613565b90508281526020810184848401111561268e5761268d6125ae565b5b612699848285611a11565b509392505050565b600082601f8301126126b6576126b5611de9565b5b81516126c684826020860161265f565b91505092915050565b6000602082840312156126e5576126e4611ab1565b5b600082015167ffffffffffffffff81111561270357612702611ab6565b5b61270f848285016126a1565b91505092915050565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b61274d81612718565b82525050565b60006060820190506127686000830186611c9f565b6127756020830185611c9f565b6127826040830184612744565b949350505050565b60008151905061279981611b23565b92915050565b6000602082840312156127b5576127b4611ab1565b5b60006127c38482850161278a565b91505092915050565b60006040820190506127e16000830185611c9f565b6127ee6020830184612744565b9392505050565b600081905092915050565b600061280b82611c28565b61281581856127f5565b9350612825818560208601611a11565b80840191505092915050565b6000819050919050565b61284c61284782612718565b612831565b82525050565b600061285e8285612800565b915061286a828461283b565b600182019150819050939250505056fea26469706673582212204772d816079e17b2b5b46a7c1e6e601d0d99cad6bbcef3c87ed27add7cf6c20f64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80636e0505e111610097578063a457c2d711610066578063a457c2d7146102c1578063a9059cbb146102f1578063bfd83c5414610321578063dd62ed3e1461033d57610100565b80636e0505e11461023b57806370a082311461025757806395d89b41146102875780639f284be7146102a557610100565b806323b872dd116100d357806323b872dd146101a1578063313ce567146101d157806339509351146101ef57806340c10f191461021f57610100565b806306fdde0314610105578063095ea7b3146101235780631744ff9c1461015357806318160ddd14610183575b600080fd5b61010d61036d565b60405161011a9190611a85565b60405180910390f35b61013d60048036038101906101389190611b4f565b6103ff565b60405161014a9190611baa565b60405180910390f35b61016d60048036038101906101689190611bfb565b610422565b60405161017a9190611c7d565b60405180910390f35b61018b610474565b6040516101989190611cae565b60405180910390f35b6101bb60048036038101906101b69190611cc9565b61047e565b6040516101c89190611baa565b60405180910390f35b6101d96104ad565b6040516101e69190611d38565b60405180910390f35b61020960048036038101906102049190611b4f565b6104b6565b6040516102169190611baa565b60405180910390f35b61023960048036038101906102349190611b4f565b6104ed565b005b61025560048036038101906102509190611d8f565b610553565b005b610271600480360381019061026c9190611dbc565b610651565b60405161027e9190611cae565b60405180910390f35b61028f610699565b60405161029c9190611a85565b60405180910390f35b6102bf60048036038101906102ba9190611d8f565b61072b565b005b6102db60048036038101906102d69190611b4f565b610829565b6040516102e89190611baa565b60405180910390f35b61030b60048036038101906103069190611b4f565b6108a0565b6040516103189190611baa565b60405180910390f35b61033b60048036038101906103369190611e4e565b6108c3565b005b61035760048036038101906103529190611eae565b61091e565b6040516103649190611cae565b60405180910390f35b60606003805461037c90611f1d565b80601f01602080910402602001604051908101604052809291908181526020018280546103a890611f1d565b80156103f55780601f106103ca576101008083540402835291602001916103f5565b820191906000526020600020905b8154815290600101906020018083116103d857829003601f168201915b5050505050905090565b60008061040a6109a5565b90506104178185856109ad565b600191505092915050565b606061046d600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483610b76565b9050919050565b6000600254905090565b6000806104896109a5565b9050610496858285610b8a565b6104a1858585610c16565b60019150509392505050565b60006003905090565b6000806104c16109a5565b90506104e28185856104d3858961091e565b6104dd9190611f7d565b6109ad565b600191505092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461054557600080fd5b61054f8282610e8c565b5050565b6105a461059f600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205483610fe2565b611022565b6105fb600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546105f68363ffffffff1661102e565b611042565b600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061064e338263ffffffff16610e8c565b50565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b6060600480546106a890611f1d565b80601f01602080910402602001604051908101604052809291908181526020018280546106d490611f1d565b80156107215780601f106106f657610100808354040283529160200191610721565b820191906000526020600020905b81548152906001019060200180831161070457829003601f168201915b5050505050905090565b8063ffffffff1661073b33610651565b101561077c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161077390611ffd565b60405180910390fd5b61078c338263ffffffff1661108c565b6107e3600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546107de8363ffffffff1661102e565b611259565b600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050565b6000806108346109a5565b90506000610842828661091e565b905083811015610887576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161087e9061208f565b60405180910390fd5b61089482868684036109ad565b60019250505092915050565b6000806108ab6109a5565b90506108b8818585610c16565b600191505092915050565b6109198361091484848080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506112a3565b6112b7565b505050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b600033905090565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610a1c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a1390612121565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610a8b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a82906121b3565b60405180910390fd5b80600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92583604051610b699190611cae565b60405180910390a3505050565b6060610b8283836112c6565b905092915050565b6000610b96848461091e565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610c105781811015610c02576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bf99061221f565b60405180910390fd5b610c0f84848484036109ad565b5b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610c85576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c7c906122b1565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610cf4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ceb90612343565b60405180910390fd5b610cff838383611355565b60008060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081811015610d85576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d7c906123d5565b60405180910390fd5b8181036000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef84604051610e739190611cae565b60405180910390a3610e8684848461135a565b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610efb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ef290612441565b60405180910390fd5b610f0760008383611355565b8060026000828254610f199190611f7d565b92505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610fca9190611cae565b60405180910390a3610fde6000838361135a565b5050565b6000610fed8361135f565b610ffe57610ffb600061102e565b92505b61101a611013848463ffffffff16600161136c565b6000611412565b905092915050565b61102b8161149c565b50565b600061103b826002611509565b9050919050565b600061104d8361135f565b61105e5761105b600061102e565b92505b6110678261135f565b61107857611075600061102e565b91505b61108483836000611593565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036110fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110f2906124d3565b60405180910390fd5b61110782600083611355565b60008060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508181101561118d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161118490612565565b60405180910390fd5b8181036000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081600260008282540392505081905550600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516112409190611cae565b60405180910390a36112548360008461135a565b505050565b60006112648361135f565b61127557611272600061102e565b92505b61127e8261135f565b61128f5761128c600061102e565b91505b61129b83836000611639565b905092915050565b60006112b08260026116df565b9050919050565b6112c233838361178d565b5050565b6060605d73ffffffffffffffffffffffffffffffffffffffff1663d6ad57cd848460001c6040518363ffffffff1660e01b8152600401611307929190612585565b600060405180830381865afa158015611324573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061134d91906126cf565b905092915050565b505050565b505050565b6000808214159050919050565b600080821561138157600160f81b9050611389565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff16633e63c50a8686846040518463ffffffff1660e01b81526004016113c793929190612753565b602060405180830381865afa1580156113e4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611408919061279f565b9150509392505050565b6000605d73ffffffffffffffffffffffffffffffffffffffff16634be68d20848460f81b6040518363ffffffff1660e01b81526004016114539291906127cc565b602060405180830381865afa158015611470573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611494919061279f565b905092915050565b605d73ffffffffffffffffffffffffffffffffffffffff16634ee071a1826040518263ffffffff1660e01b81526004016114d69190611cae565b60006040518083038186803b1580156114ee57600080fd5b505afa158015611502573d6000803e3d6000fd5b5050505050565b6000605d73ffffffffffffffffffffffffffffffffffffffff1663e71746b8848460f81b6040518363ffffffff1660e01b815260040161154a9291906127cc565b602060405180830381865afa158015611567573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061158b919061279f565b905092915050565b60008082156115a857600160f81b90506115b0565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff16638c14cc218686846040518463ffffffff1660e01b81526004016115ee93929190612753565b602060405180830381865afa15801561160b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061162f919061279f565b9150509392505050565b600080821561164e57600160f81b9050611656565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff1663f953e4278686846040518463ffffffff1660e01b815260040161169493929190612753565b602060405180830381865afa1580156116b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116d5919061279f565b9150509392505050565b600080838360f81b6040516020016116f8929190612852565b6040516020818303038152906040529050605d73ffffffffffffffffffffffffffffffffffffffff16634b252ec8826040518263ffffffff1660e01b81526004016117439190611c7d565b602060405180830381865afa158015611760573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611784919061279f565b91505092915050565b6117de6117d982600560008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546118fb565b611022565b611827600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482611259565b600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506118b3600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482611042565b600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550505050565b60006119068361135f565b61191757611914600061102e565b92505b6119208261135f565b6119315761192e600061102e565b91505b6119476119408484600061194f565b6000611412565b905092915050565b600080821561196457600160f81b905061196c565b600060f81b90505b605d73ffffffffffffffffffffffffffffffffffffffff1663694daf728686846040518463ffffffff1660e01b81526004016119aa93929190612753565b602060405180830381865afa1580156119c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119eb919061279f565b9150509392505050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611a2f578082015181840152602081019050611a14565b60008484015250505050565b6000601f19601f8301169050919050565b6000611a57826119f5565b611a618185611a00565b9350611a71818560208601611a11565b611a7a81611a3b565b840191505092915050565b60006020820190508181036000830152611a9f8184611a4c565b905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611ae682611abb565b9050919050565b611af681611adb565b8114611b0157600080fd5b50565b600081359050611b1381611aed565b92915050565b6000819050919050565b611b2c81611b19565b8114611b3757600080fd5b50565b600081359050611b4981611b23565b92915050565b60008060408385031215611b6657611b65611ab1565b5b6000611b7485828601611b04565b9250506020611b8585828601611b3a565b9150509250929050565b60008115159050919050565b611ba481611b8f565b82525050565b6000602082019050611bbf6000830184611b9b565b92915050565b6000819050919050565b611bd881611bc5565b8114611be357600080fd5b50565b600081359050611bf581611bcf565b92915050565b600060208284031215611c1157611c10611ab1565b5b6000611c1f84828501611be6565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000611c4f82611c28565b611c598185611c33565b9350611c69818560208601611a11565b611c7281611a3b565b840191505092915050565b60006020820190508181036000830152611c978184611c44565b905092915050565b611ca881611b19565b82525050565b6000602082019050611cc36000830184611c9f565b92915050565b600080600060608486031215611ce257611ce1611ab1565b5b6000611cf086828701611b04565b9350506020611d0186828701611b04565b9250506040611d1286828701611b3a565b9150509250925092565b600060ff82169050919050565b611d3281611d1c565b82525050565b6000602082019050611d4d6000830184611d29565b92915050565b600063ffffffff82169050919050565b611d6c81611d53565b8114611d7757600080fd5b50565b600081359050611d8981611d63565b92915050565b600060208284031215611da557611da4611ab1565b5b6000611db384828501611d7a565b91505092915050565b600060208284031215611dd257611dd1611ab1565b5b6000611de084828501611b04565b91505092915050565b600080fd5b600080fd5b600080fd5b60008083601f840112611e0e57611e0d611de9565b5b8235905067ffffffffffffffff811115611e2b57611e2a611dee565b5b602083019150836001820283011115611e4757611e46611df3565b5b9250929050565b600080600060408486031215611e6757611e66611ab1565b5b6000611e7586828701611b04565b935050602084013567ffffffffffffffff811115611e9657611e95611ab6565b5b611ea286828701611df8565b92509250509250925092565b60008060408385031215611ec557611ec4611ab1565b5b6000611ed385828601611b04565b9250506020611ee485828601611b04565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611f3557607f821691505b602082108103611f4857611f47611eee565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611f8882611b19565b9150611f9383611b19565b9250828201905080821115611fab57611faa611f4e565b5b92915050565b7f6d757374206861766520656e6f75676820746f6b656e7320746f207772617000600082015250565b6000611fe7601f83611a00565b9150611ff282611fb1565b602082019050919050565b6000602082019050818103600083015261201681611fda565b9050919050565b7f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760008201527f207a65726f000000000000000000000000000000000000000000000000000000602082015250565b6000612079602583611a00565b91506120848261201d565b604082019050919050565b600060208201905081810360008301526120a88161206c565b9050919050565b7f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460008201527f7265737300000000000000000000000000000000000000000000000000000000602082015250565b600061210b602483611a00565b9150612116826120af565b604082019050919050565b6000602082019050818103600083015261213a816120fe565b9050919050565b7f45524332303a20617070726f766520746f20746865207a65726f20616464726560008201527f7373000000000000000000000000000000000000000000000000000000000000602082015250565b600061219d602283611a00565b91506121a882612141565b604082019050919050565b600060208201905081810360008301526121cc81612190565b9050919050565b7f45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000600082015250565b6000612209601d83611a00565b9150612214826121d3565b602082019050919050565b60006020820190508181036000830152612238816121fc565b9050919050565b7f45524332303a207472616e736665722066726f6d20746865207a65726f20616460008201527f6472657373000000000000000000000000000000000000000000000000000000602082015250565b600061229b602583611a00565b91506122a68261223f565b604082019050919050565b600060208201905081810360008301526122ca8161228e565b9050919050565b7f45524332303a207472616e7366657220746f20746865207a65726f206164647260008201527f6573730000000000000000000000000000000000000000000000000000000000602082015250565b600061232d602383611a00565b9150612338826122d1565b604082019050919050565b6000602082019050818103600083015261235c81612320565b9050919050565b7f45524332303a207472616e7366657220616d6f756e742065786365656473206260008201527f616c616e63650000000000000000000000000000000000000000000000000000602082015250565b60006123bf602683611a00565b91506123ca82612363565b604082019050919050565b600060208201905081810360008301526123ee816123b2565b9050919050565b7f45524332303a206d696e7420746f20746865207a65726f206164647265737300600082015250565b600061242b601f83611a00565b9150612436826123f5565b602082019050919050565b6000602082019050818103600083015261245a8161241e565b9050919050565b7f45524332303a206275726e2066726f6d20746865207a65726f2061646472657360008201527f7300000000000000000000000000000000000000000000000000000000000000602082015250565b60006124bd602183611a00565b91506124c882612461565b604082019050919050565b600060208201905081810360008301526124ec816124b0565b9050919050565b7f45524332303a206275726e20616d6f756e7420657863656564732062616c616e60008201527f6365000000000000000000000000000000000000000000000000000000000000602082015250565b600061254f602283611a00565b915061255a826124f3565b604082019050919050565b6000602082019050818103600083015261257e81612542565b9050919050565b600060408201905061259a6000830185611c9f565b6125a76020830184611c9f565b9392505050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6125eb82611a3b565b810181811067ffffffffffffffff8211171561260a576126096125b3565b5b80604052505050565b600061261d611aa7565b905061262982826125e2565b919050565b600067ffffffffffffffff821115612649576126486125b3565b5b61265282611a3b565b9050602081019050919050565b600061267261266d8461262e565b612613565b90508281526020810184848401111561268e5761268d6125ae565b5b612699848285611a11565b509392505050565b600082601f8301126126b6576126b5611de9565b5b81516126c684826020860161265f565b91505092915050565b6000602082840312156126e5576126e4611ab1565b5b600082015167ffffffffffffffff81111561270357612702611ab6565b5b61270f848285016126a1565b91505092915050565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b61274d81612718565b82525050565b60006060820190506127686000830186611c9f565b6127756020830185611c9f565b6127826040830184612744565b949350505050565b60008151905061279981611b23565b92915050565b6000602082840312156127b5576127b4611ab1565b5b60006127c38482850161278a565b91505092915050565b60006040820190506127e16000830185611c9f565b6127ee6020830184612744565b9392505050565b600081905092915050565b600061280b82611c28565b61281581856127f5565b9350612825818560208601611a11565b80840191505092915050565b6000819050919050565b61284c61284782612718565b612831565b82525050565b600061285e8285612800565b915061286a828461283b565b600182019150819050939250505056fea26469706673582212204772d816079e17b2b5b46a7c1e6e601d0d99cad6bbcef3c87ed27add7cf6c20f64736f6c63430008130033",
  "devdoc": {
    "events": {
      "Approval(address,address,uint256)": {
        "details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
      }
    },
    "kind": "dev",
    "methods": {
      "allowance(address,address)": {
        "details": "See {IERC20-allowance}."
      },
      "approve(address,uint256)": {
        "details": "See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."
      },
      "balanceOf(address)": {
        "details": "See {IERC20-balanceOf}."
      },
      "decimals()": {
        "details": "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."
      },
      "decreaseAllowance(address,uint256)": {
        "details": "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."
      },
      "increaseAllowance(address,uint256)": {
        "details": "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."
      },
      "name()": {
        "details": "Returns the name of the token."
      },
      "symbol()": {
        "details": "Returns the symbol of the token, usually a shorter version of the name."
      },
      "totalSupply()": {
        "details": "See {IERC20-totalSupply}."
      },
      "transfer(address,uint256)": {
        "details": "See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."
      },
      "transferFrom(address,address,uint256)": {
        "details": "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 43,
        "contract": "contracts/NormalETHERC20.sol:NormalETHERC20",
        "label": "_balances",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 49,
        "contract": "contracts/NormalETHERC20.sol:NormalETHERC20",
        "label": "_allowances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 51,
        "contract": "contracts/NormalETHERC20.sol:NormalETHERC20",
        "label": "_totalSupply",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 53,
        "contract": "contracts/NormalETHERC20.sol:NormalETHERC20",
        "label": "_name",
        "offset": 0,
        "slot": "3",
        "type": "t_string_storage"
      },
      {
        "astId": 55,
        "contract": "contracts/NormalETHERC20.sol:NormalETHERC20",
        "label": "_symbol",
        "offset": 0,
        "slot": "4",
        "type": "t_string_storage"
      },
      {
        "astId": 3888,
        "contract": "contracts/NormalETHERC20.sol:NormalETHERC20",
        "label": "_encBalances",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_userDefinedValueType(euint32)7330)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_address,t_userDefinedValueType(euint32)7330)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => euint32)",
        "numberOfBytes": "32",
        "value": "t_userDefinedValueType(euint32)7330"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(euint32)7330": {
        "encoding": "inplace",
        "label": "euint32",
        "numberOfBytes": "32"
      }
    }
  }
}