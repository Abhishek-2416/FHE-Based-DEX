{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/NormalBTCERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"fhevm/lib/TFHE.sol\";\n\ncontract NormalBTCERC20 is ERC20 {\n\n    address immutable i_owner;\n    mapping(address => euint32) private _encBalances;\n\n    constructor() ERC20(\"BTCERC20\",\"ETH\") {\n        i_owner = msg.sender;\n        mint(msg.sender, 1000000);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 3;\n    }\n\n    function mint(address to, uint256 amount) public {\n        if (msg.sender != i_owner) {\n            revert ();\n        }\n        _mint(to, amount);\n    }\n\n    function wrap(uint32 amount) public {\n        require(balanceOf(msg.sender) >= amount, \"must have enough tokens to wrap\");\n        _burn(msg.sender, amount);\n        _encBalances[msg.sender] = TFHE.add(_encBalances[msg.sender], TFHE.asEuint32(amount));\n    }\n\n    function unwrap(uint32 amount) public {\n        TFHE.optReq(TFHE.gt(_encBalances[msg.sender], amount));\n\n        _encBalances[msg.sender] = TFHE.sub(_encBalances[msg.sender], TFHE.asEuint32(amount));\n\n        _mint(msg.sender, amount);\n    }\n\n    function transferEncrypted(address to, bytes calldata encryptedAmount) public {\n        _transferEncrypted(to, TFHE.asEuint32(encryptedAmount));\n    }\n\n    // Transfers an amount from the message sender address to the `to` address.\n    function _transferEncrypted(address to, euint32 amount) internal {\n        _transferImpl(msg.sender, to, amount);\n    }\n\n    // Transfers an encrypted amount.\n    function _transferImpl(address from, address to, euint32 amount) internal {\n        // Make sure the sender has enough tokens.\n        TFHE.optReq(TFHE.le(amount, _encBalances[from]));\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        _encBalances[to] = TFHE.add(_encBalances[to], amount);\n        _encBalances[from] = TFHE.sub(_encBalances[from], amount);\n    }\n\n    function balanceOfEncrypted(bytes32 publicKey) public view returns (bytes memory) {\n        return TFHE.reencrypt(_encBalances[msg.sender], publicKey);\n    }\n}\n"
    },
    "fhevm/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity 0.8.19;\n\ninterface FhevmLib {\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheNeg(uint256 ct) external pure returns (uint256 result);\n\n    function fheNot(uint256 ct) external pure returns (uint256 result);\n\n    function optimisticRequire(uint256 ct) external view;\n\n    function reencrypt(uint256 ct, uint256 publicKey) external view returns (bytes memory);\n\n    function fhePubKey(bytes1 fromLib) external view returns (bytes memory result);\n\n    function verifyCiphertext(bytes memory input) external pure returns (uint256 result);\n\n    function cast(uint256 ct, bytes1 toType) external pure returns (uint256 result);\n\n    function trivialEncrypt(uint256 ct, bytes1 toType) external pure returns (uint256 result);\n\n    function decrypt(uint256 ct) external view returns (uint256 result);\n\n    function fheRand(bytes1 inp) external view returns (uint256 result);\n}\n\naddress constant EXT_TFHE_LIBRARY = address(93);\n\nlibrary Impl {\n    // 32 bytes for the 'byte' type header + 48 bytes for the NaCl anonymous\n    // box overhead + 4 bytes for the plaintext value.\n    uint256 constant reencryptedSize = 32 + 48 + 4;\n\n    // 32 bytes for the 'byte' header + 16553 bytes of key data.\n    uint256 constant fhePubKeySize = 32 + 16553;\n\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function and(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(uint256 ct) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNeg(ct);\n    }\n\n    function not(uint256 ct) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNot(ct);\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\n    function cmux(uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\n        // result = (ifTrue - ifFalse) * control + ifFalse\n        uint256 subOutput = FhevmLib(address(EXT_TFHE_LIBRARY)).fheSub(ifTrue, ifFalse, bytes1(0x00));\n        uint256 mulOutput = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMul(control, subOutput, bytes1(0x00));\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheAdd(mulOutput, ifFalse, bytes1(0x00));\n    }\n\n    function optReq(uint256 ciphertext) internal view {\n        FhevmLib(address(EXT_TFHE_LIBRARY)).optimisticRequire(ciphertext);\n    }\n\n    function reencrypt(uint256 ciphertext, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return FhevmLib(address(EXT_TFHE_LIBRARY)).reencrypt(ciphertext, uint256(publicKey));\n    }\n\n    function fhePubKey() internal view returns (bytes memory key) {\n        // Set a byte value of 1 to signal the call comes from the library.\n        key = FhevmLib(address(EXT_TFHE_LIBRARY)).fhePubKey(bytes1(0x01));\n    }\n\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\n        bytes memory input = bytes.concat(_ciphertextBytes, bytes1(_toType));\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).verifyCiphertext(input);\n    }\n\n    function cast(uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).cast(ciphertext, bytes1(toType));\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function decrypt(uint256 ciphertext) internal view returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).decrypt(ciphertext);\n    }\n\n    function rand(uint8 randType) internal view returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheRand(bytes1(randType));\n    }\n}\n"
    },
    "fhevm/lib/TFHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity 0.8.19;\n\ntype ebool is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\n\nlibrary Common {\n    // Values used to communicate types to the runtime.\n    uint8 internal constant ebool_t = 0;\n    uint8 internal constant euint8_t = 0;\n    uint8 internal constant euint16_t = 1;\n    uint8 internal constant euint32_t = 2;\n}\n\nimport \"./Impl.sol\";\n\nlibrary TFHE {\n    euint8 constant NIL8 = euint8.wrap(0);\n    euint16 constant NIL16 = euint16.wrap(0);\n    euint32 constant NIL32 = euint32.wrap(0);\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint8 b) internal pure returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(uint8 a, euint8 b) internal pure returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(uint8 a, euint8 b) internal pure returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(uint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(uint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(uint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(uint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint8 a, euint8 b) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cmux(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'a'.\n    // If 'control's value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 ctrl = asEuint16(asEuint8(control));\n        return euint16.wrap(Impl.cmux(euint16.unwrap(ctrl), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'a'.\n    // If 'control's value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 ctrl = asEuint32(asEuint8(control));\n        return euint32.wrap(Impl.cmux(euint32.unwrap(ctrl), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Cast an encrypted integer from euint16 to euint8.\n    function asEuint8(euint16 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint8.\n    function asEuint8(euint32 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint8 to ebool.\n    function asEbool(euint8 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted boolean.\n    function asEbool(bytes memory ciphertext) internal pure returns (ebool) {\n        return asEbool(asEuint8(ciphertext));\n    }\n\n    // Convert a plaintext boolean to an encrypted boolean.\n    function asEbool(bool value) internal pure returns (ebool) {\n        if (value) {\n            return asEbool(asEuint8(1));\n        } else {\n            return asEbool(asEuint8(0));\n        }\n    }\n\n    // Cast an encrypted integer from euint8 to euint16.\n    function asEuint16(euint8 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint16.\n    function asEuint16(euint32 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint16 to ebool.\n    function asEbool(euint16 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Cast an encrypted integer from euint8 to euint32.\n    function asEuint32(euint8 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint32.\n    function asEuint32(euint16 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint32 to ebool.\n    function asEbool(euint32 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    function neg(euint8 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    function not(euint8 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    function neg(euint16 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    function not(euint16 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    function neg(euint32 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    function not(euint32 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint8 integer.\n    function asEuint8(bytes memory ciphertext) internal pure returns (euint8) {\n        return euint8.wrap(Impl.verify(ciphertext, Common.euint8_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint8 integer.\n    function asEuint8(uint256 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 ciphertext.\n    function reencrypt(euint8 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint8.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint8 ciphertext.\n    function reencrypt(\n        euint8 value,\n        bytes32 publicKey,\n        uint8 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint8.unwrap(value) != 0) {\n            return Impl.reencrypt(euint8.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint8.unwrap(asEuint8(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint8 value) internal view returns (uint8) {\n        return uint8(Impl.decrypt(euint8.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint16 integer.\n    function asEuint16(bytes memory ciphertext) internal pure returns (euint16) {\n        return euint16.wrap(Impl.verify(ciphertext, Common.euint16_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint16 integer.\n    function asEuint16(uint256 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint16 ciphertext.\n    function reencrypt(euint16 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint16.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint16 ciphertext.\n    function reencrypt(\n        euint16 value,\n        bytes32 publicKey,\n        uint16 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint16.unwrap(value) != 0) {\n            return Impl.reencrypt(euint16.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint16.unwrap(asEuint16(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint16 value) internal view returns (uint16) {\n        return uint16(Impl.decrypt(euint16.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint32 integer.\n    function asEuint32(bytes memory ciphertext) internal pure returns (euint32) {\n        return euint32.wrap(Impl.verify(ciphertext, Common.euint32_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint32 integer.\n    function asEuint32(uint256 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint32 ciphertext.\n    function reencrypt(euint32 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint32.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint32 ciphertext.\n    function reencrypt(\n        euint32 value,\n        bytes32 publicKey,\n        uint32 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint32.unwrap(value) != 0) {\n            return Impl.reencrypt(euint32.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint32.unwrap(asEuint32(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint32 value) internal view returns (uint32) {\n        return uint32(Impl.decrypt(euint32.unwrap(value)));\n    }\n\n    // Optimistically require that 'b' is true.\n    //\n    // This function does not evaluate 'b' at the time of the call.\n    // Instead, it accumulates all optimistic requires and evaluates a single combined\n    // require at the end of the transaction. A side effect of this mechanism\n    // is that a method call with a failed optimistic require will always incur the full\n    // gas cost, as if all optimistic requires were true. Yet, the transaction will be\n    // reverted at the end if any of the optimisic requires were false.\n    //\n    // Exceptions to above rule are reencryptions and decryptions via\n    // TFHE.reencrypt() and TFHE.decrypt(), respectively. If either of them\n    // are encountered and if optimistic requires have been used before in the\n    // txn, the optimisic requires will be immediately evaluated. Rationale is\n    // that we want to avoid decrypting or reencrypting a value if the txn is about\n    // to fail and be reverted anyway at the end. Checking immediately and reverting on the spot\n    // would avoid unnecessary decryptions.\n    //\n    // The benefit of optimistic requires is that they are faster than non-optimistic ones,\n    // because there is a single call to the decryption oracle per transaction, irrespective\n    // of how many optimistic requires were used.\n    function optReq(ebool b) internal view {\n        Impl.optReq(ebool.unwrap(b));\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(ebool value) internal view returns (bool) {\n        return (Impl.decrypt(ebool.unwrap(value)) != 0);\n    }\n\n    // Converts an 'ebool' to an 'euint8'.\n    function asEuint8(ebool b) internal pure returns (euint8) {\n        return euint8.wrap(ebool.unwrap(b));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 value.\n    function reencrypt(ebool value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(ebool.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 value.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    function reencrypt(\n        ebool value,\n        bytes32 publicKey,\n        bool defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (ebool.unwrap(value) != 0) {\n            return Impl.reencrypt(ebool.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(ebool.unwrap(asEbool(defaultValue)), publicKey);\n        }\n    }\n\n    // Returns the network public FHE key.\n    function fhePubKey() internal view returns (bytes memory) {\n        return Impl.fhePubKey();\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint8() internal view returns (euint8) {\n        return euint8.wrap(Impl.rand(Common.euint8_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint16() internal view returns (euint16) {\n        return euint16.wrap(Impl.rand(Common.euint16_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint32() internal view returns (euint32) {\n        return euint32.wrap(Impl.rand(Common.euint32_t));\n    }\n}\n\nusing {tfheBinaryOperatorAdd8 as +} for euint8 global;\n\nfunction tfheBinaryOperatorAdd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub8 as -} for euint8 global;\n\nfunction tfheBinaryOperatorSub8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul8 as *} for euint8 global;\n\nfunction tfheBinaryOperatorMul8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd8 as &} for euint8 global;\n\nfunction tfheBinaryOperatorAnd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr8 as |} for euint8 global;\n\nfunction tfheBinaryOperatorOr8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor8 as ^} for euint8 global;\n\nfunction tfheBinaryOperatorXor8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg8 as -} for euint8 global;\n\nfunction tfheUnaryOperatorNeg8(euint8 input) pure returns (euint8) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot8 as ~} for euint8 global;\n\nfunction tfheUnaryOperatorNot8(euint8 input) pure returns (euint8) {\n    return TFHE.not(input);\n}\n\nusing {tfheBinaryOperatorAdd16 as +} for euint16 global;\n\nfunction tfheBinaryOperatorAdd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub16 as -} for euint16 global;\n\nfunction tfheBinaryOperatorSub16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul16 as *} for euint16 global;\n\nfunction tfheBinaryOperatorMul16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd16 as &} for euint16 global;\n\nfunction tfheBinaryOperatorAnd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr16 as |} for euint16 global;\n\nfunction tfheBinaryOperatorOr16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor16 as ^} for euint16 global;\n\nfunction tfheBinaryOperatorXor16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg16 as -} for euint16 global;\n\nfunction tfheUnaryOperatorNeg16(euint16 input) pure returns (euint16) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot16 as ~} for euint16 global;\n\nfunction tfheUnaryOperatorNot16(euint16 input) pure returns (euint16) {\n    return TFHE.not(input);\n}\n\nusing {tfheBinaryOperatorAdd32 as +} for euint32 global;\n\nfunction tfheBinaryOperatorAdd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub32 as -} for euint32 global;\n\nfunction tfheBinaryOperatorSub32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul32 as *} for euint32 global;\n\nfunction tfheBinaryOperatorMul32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd32 as &} for euint32 global;\n\nfunction tfheBinaryOperatorAnd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr32 as |} for euint32 global;\n\nfunction tfheBinaryOperatorOr32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor32 as ^} for euint32 global;\n\nfunction tfheBinaryOperatorXor32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg32 as -} for euint32 global;\n\nfunction tfheUnaryOperatorNeg32(euint32 input) pure returns (euint32) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot32 as ~} for euint32 global;\n\nfunction tfheUnaryOperatorNot32(euint32 input) pure returns (euint32) {\n    return TFHE.not(input);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}